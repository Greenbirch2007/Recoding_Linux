第１４章　处理用户输入


本章内容

传递参数
跟踪参数
移动变量
处理选项
将选项标准化
获得用户输入


前面已经介绍如何编写脚本，处理数据，变量和linux系统上的文件。有时需要编写的脚本还得能够与使用者交互。
bash shell提供了一些不同的方法来从用户处获得数据，包括命令行参数(添加在命令后的数据)，命令行选项(可修改命令行为单个字母)以及直接从键盘读取输入的能力

１４．１　命令行参数

向shell脚本传递数据的最基本方法是使用命令行参数。命令行参数允许在运行脚本是想命令行添加数据

./tt  10 30 

脚本tt传递了两个命令行参数(10和30).脚本会通过特殊的变量来处理命令行参数。

１４．１．１　　读取参数

bash shell会将一些称为位置参数(positional parameter)的特殊变量分配给输入到命令行中的所有参数。这也包括shell所执行的脚本名称。位置参数变量是标准的数字：$0是程序名，$1是第一个参数，一次类推，直到第九个参数$9

可以在shell脚本中像使用其他变量一样使用$1变量。shell脚本会自动将命令行参数的值分配给变量，不需要你做任何处理

如果需要输入更多的命令行参数，则每个参数都必须用空格分开

shell会将每个参数分配给对应的变量

前面的脚本，用到的命令行参数都是数值。也可以在命令行上用文本字符串

shell将输入到命令行的字符串值传给脚本。但碰到含有空格的文本字符串时就会出现问题

记住，每个参数都是用空格分隔的，所以shell会将空格当成两个值的分隔符。要在参数值中包含空格，必须用引号(单引号或双引号均可)

说明，将文本字符串作为参数传递时，引号并非数据的一部分。它们只是表明数据的起止位置

如果脚本需要的命令行参数超过９个，可以需要第９个变量之后，变量数字周围加上花括号，比如{10}
这项技术允许你根据需要向脚本添加任意多的命令行参数

１４．１．２　　读取脚本名

可以用$0参数获取shell在命令行启动的脚本名

此时用bash　脚本名

也有一些小问题。如果你要编写一个根据脚本名来执行不同功能的脚本，就得多做点工作。你得把脚本的运行路径给剥离掉。
另外，还要删除与脚本名混在一起的名

basename命令会返回不包含路径的脚本名

脚本可以创建两个不同的文件名：一个通过复制文件创建(addem),另一个通过链接创建(multem).在两种情况下都会先获得脚本的基本名称，然后根据该值执行相应的功能

１４．１．３　测试参数

在shell脚本中使用命令行参数时要注意
当脚本认为参数变量中会有数据而实际上没有时，脚本很有可能会产生错误消息。

在使用参数前一定要检查其中是否存在数据
使用-n测试来检查命令行参数$1中是否有数据

１４．２　　特殊参数变量

在bash shell中是有些特殊变量，它们会记录命令行参数

１４．２．１　　参数停机

在脚本中使用命令行参数之前应该检查一下命令行参数。对于使用多个命令行参数的脚本来说，有些麻烦

你可以统计一下命令行中输入多少个参数，无需测试每个参数。bash shell为此提供了一个特殊变量。
特殊变量$#含有脚本运行时携带的命令行参数的个数。可以在脚本中任何地方使用这个特殊变量，就跟普通变量议案该

可以在使用参数前测试参数的总数

不能在花括号诶使用美元符号。必须将美元符号换成感叹号

${!#}代表最后一个命令行参数变量

$#变量的值赋给了变量params,然后也按特殊命令行参数变量的格式使用了这个变量。两种方法都没有问题
注意，当命令行上没有任何参数时，$#的值为0,params变量的值也一样，但${!#}变量会返回命令行用到的脚本名

１４．２．２　抓取所有的数据

有时候需要找去命令行上的所有参数。这时候不需要先用$#变量来判断命令行上有多少参数，然后再进行遍历，你可以用一组其他的特殊变量来解决这个问题

$*和$@变量可以用来轻松访问所有的参数。这两个变量都能够在单个变量中存储所有的命令行参数

$*变量会将命令行上提供的所有参数当做一个单词保存。这个单词包含了命令行中出现的每一个参数值。基本上$*变量会将这些参数视为一个整体，而不是多个个体

另一方面，$@变量会将命令行上提供的所有参数当做同一个字符串中的多个独立的单词。
这样你能够遍历所有的参数值，得到每个参数。这通常通过for命令完成

表面上，两个变量变量产生的是同样的输出，都显示出了所有命令行参数

通过使用for命令遍历两个特殊变量，你能看到它们是如何不同地处理命令行参数的。$*变量会将所有参数当成单个参数，而$@变量会单独处理每个参数。这是遍历命令行参数的一个方法

１４．３　移动变量

bash shell的shift命令能够用来操作命令行参数。shift命令会根据它们的相对位置来移动命令行参数

在使用shift命令时，默认情况下它会将每个参数变量向左移动一个位置。所以,变量$3的值会移到$2中，变量$1的值会被删除(注意，变量$0的值，也就是程序名，不会改变)

这是遍历命令行参数的另一个好方法，尤其是在你不知道道题有多少个参数时，你可以只操作第一个参数，移动参数，然后继续操作第一个参数

测试玩第一个参数后，shift命令会将所有参数的位置移动一个位置

技巧。如果某个参数被移出，它的值就被丢弃了，无法再恢复

另外，你也可以一次性移动多个位置，只需要给shirt命令听一个参数，指明要移动的位置即可


通过使用shift命令的参数，就可以轻松地跳过不需要的参数

１４．４　处理选项

选项是跟在单波折号后面的单个字母，它能改变命令的行为

１４．４．１　查找选项

1. 处理简单选项

在提取每个单独参数是，用case语句来判断某个参数是否为选项

case语句会检查每个参数是不是有效选项。如果是的话，就运行对应case语句中的命令。
不管选项按什么顺序出现在命令行上
case语句在命令行参数中找到一个选项，就处理一个选项。
如果命令行上还提供了掐参数，你可以在case语句的通用情况处理部分中处理

２．分离参数和选项

你会经常遇到想在shell脚本中同时使用选项和参数的情况。linux中处理这个问题的标准方式是用特殊字符来将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始
对linux来说，这个特殊字符是双破折线(--).shell会用双破折线来表明列表结束。
在双破折线之后，脚本就可以放心地将剩下的命令行参数当做参数，而不是选项来处理了
要检查双破折线，只要在case语句加一句就可以

在遇到双破折线时，脚本用break命令来跳出while循环。由于过早地跳出了循环，我们需要再加一条shift命令来将双破折线移除参数变量

对于第一个测试，试试用一组普通的选项和参数来运行这个脚本

结果说明在处理时脚本认为所有的命令行参数都是选项。接下来，进行同样的测试，只是这次会用双破线来将命令行上的选项和参数划分开来

当脚本遇到双破折线时，它会停止处理选项，并将剩下的参数都当做命令行参数

３．处理带值的选项

有些选项会带上一个额外的参数值。在这种情况下
当命令行选项要求额外的参数时，脚本必须能检测到并正确处理


只用这些基本的特性，整个过程就能正常工作。不管按照什么顺序放置选项

在linux中，合并选项很常见，而且如果脚本想要对用户更友好，也要给用户提供这种特性。

１４．４．２　　使用getopt命令

getopt能够识别命令行参数，从而在脚本中解析它们

１．命令的格式

getopt命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式

getopt optstring parameters

optstring是这个过程的关键所在。它定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值

首先，在optstring中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。getopt命令会基于你定义的optstring解析提供的参数

如果指定了一个不在optstring中的选项，默认情况下，getopt命令会产生一条错消息

-q选项可以忽略错误信息

注意，getopt命令选项必须出现在optstring之前。现在应该可以在脚本中使用此命令吃力命令行选项了

２．在脚本中使用getopt

可以在脚本中使用getopt来格式化所携带的任何命令行选项或参数
set命令能够处理shell中的各种变量
getopt命令并不擅长处理空格和引号的参数值。它会将空格当做参数分隔符，而不是根据双引号将二者当做一个参数

１４．４．３　　使用更高级的getopts

每次调用它时，它一次只处理命令行上检测到的一个参数。处理完所有的参数后，它会退出并返回一个大于０的退出状态码。这让它非常适合用于解析命令行所有参数的循环中

getopts optstring variable

getopts命令会用到两个环境变量。如果选型需要跟一个参数值，OPTARG环境变量就会保存这个值。OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。这样你就能在处理完选项之后继续处理其他命令行参数了

while语句定义了getopts命令，指明了要查找哪些命令行选项，以及每次迭代中存储它们的变量名(opt)

getopts命令解析命令行选项时会移除开头的单破折线，所以在case定义中不用单破折线

getopts，可以在参数值中包含空格
也可以将选项字母和参数值放在一起使用，而不用加空格

getopts命令能够从-b选项中正确解析出test1值。除此之外,getopts还能够将命令行上找到的所有未定义的选项统一输出成功问题好


optstring中未定义的选项字母会以问好形式发送给代码

getopts命令知道何时停止处理选项，并将参数留给你处理。
在getoptrs处理每个选项时，它会将OPTIND环境变量值增加一。
在getopts完成处理时，你可以使用shift命令和OPTIND值来移动参数

１４．５　　将选项标准化

在创建shell脚本时，可以控制怎么做。常用的linux命令选项

-a 　显示所有对象
-c 生成一个计数
-d 指定一个目录
-e  扩展一个对象
-f 指定读入数据的文件
-h 显示命令的帮助信息
-i 忽略文本大小写
-l 产生输出的长格式版本
-n 使用非交互模式(批处理)
-o 将所有输出重定向到的指定的输出文件
-q 以安静模式运行
-r 递归地处理目录和文件
-s 以安静模式运行
-v 生成详细输出
-x 排除某个对对象
-y 对所有问题回答yes

14.6  获得用户输入

14.6.1 基本的读取

read命令从标准输入(键盘)或另一个文件描述符中接受输入。在收到输入后，read命令会将数据放进一个变量。

生成提示的echo命令使用了-n选项。该选项不会在字符串末尾输出换行符，允许脚本用户紧跟其后输入数据，而不是下一行
实际上，read命令包括了-p选项，允许你直接在read命令行指定提示符

read命令会将提示符后输入的所有数据分配给单个变量，要么你就指定多个变量。输入的每个数据值都会分配给变量列表中的下一个变量。如果变量数量不够，剩下的数据就全部分配给最后一个变量

也可以在read命令行中不指定变量。如果是这样，read命令会将它收到的任何数据都放进特殊环境变量REPLY中

REPLY环境变量会保存输入的所有数据，可以在shell脚本中像其他变量一样使用

１４．６．２　超时

使用read命令时要小心，脚本很可能会一直扥带脚本用户的输入。
如果不管是否有数据输入，脚本都必须继续执行，你可以用-t选项来指定一个计时器。
-t选项指定了read命令等待输入的秒数。当计时器过期后，read命令会返回一个非零退出状态码

如果计时器过期，read命令会以非零退出状态码退出，可以使用如if-then语句或while循环这种标准的结构化语句来理清所发生的具体情况。

也可以不对输入过程计时，而是让read命令来统计输入的字符数。当输入的字符达到预设的字符数时，就自动退出，将输入的数据赋给变量

-n选项和值１一起使用，告诉read命令在接受单个字符后退出。
只要按下单个字符回答后，read命令就会接受输入并将传给变量，无需按回车键

１４．６．３　　隐藏方式读取

有时你需要从脚本用户处得到输入，但又在屏幕上显示输入信息。其中典型的例子就输入的密码，
但除此之外还有很多其他需要隐藏的数据类型

-s选项可以避免在read命令中输入的数据出现在显示器上

输入提示符输入的数据不会出现在屏幕上，但会赋给变量，以便在脚本中使用

１４．６．４　从文件中读取

最后，也可以用read命令来读取linux系统上文件里保存的数据。每次调用read命令，它都会从文件中读取一行文本。当文件中再没有内容时，read命令会退出并返回非零退出状态码

其中最难的部分是将文件中的数据传给read命令。最常见的方法是对文件使用cat命令，将结果通过管道直接传给含有read命令的while命令

while循环会持续通过read命令处理文件中的行，直到read命令以非零退出状态码退出



